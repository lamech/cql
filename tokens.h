#pragma once
#include "util.h"
#include "token.h"
#include "node.h"
#include "nodeheaders.h"
#include "pathnode.h"
class Environment;

class Tokens{
 public:
  string toString();
  Environment*environment{NULL};
  Environment* getEnvironment()const{return environment;}
  Node* node_from_string(const string &description);
  int bottom;
  vector<Token*>tokens;
  bool eof();
  Token* current();
  int save();
  void restore(int x);
  void reset(){restore(0);}
  void forward();
  Tokens(vector<Token*> ts,Environment*e);
  CqlNode* parseRoot();
  bool match_cqlfeature(Node**);
  StringToken* match_stringtoken();
  CqlNode* match_cqlnode();
  PgnNode* match_pgnnode();
  PathStartNode* match_pathstartnode();
  PathCountNode* match_pathcountnode();
  PathDebugNode* match_pathdebugnode();
  PathLastPositionNode* match_pathlastpositionnode();
  Node* match_pathcountunfocused();
  OutputNode* match_outputnode();
  ResultNode* match_resultnode();
  vector<Node*> match_some_cqlfeatures();
  KeywordToken* match_keyword(string);
  Node* match_simplenode();
  PieceLoc* match_pieceloc();
  Node* match_compoundnode();
  Node* match_complexnode();
  Node* match_count_something();
  Token* match_variable();
  vector<Node*> match_some_basicnodes();
  Range* match_range();
  IntToken* match_int();
  VariationsNode* match_variationsnode();
  GameNumberNode* match_gamenumbernode();
  GameNumberNode* match_gamenumberrange();
  vector<SetBase*>* match_some_setbases();
  RayNode* match_raynode();
  Node*match_movebase();
  Node*match_movenumbernode();
  NotNode*match_notnode();
  Node*match_pinnode();
  KeywordToken*match_transformkeyword();
  KeywordToken*match_raykeyword();
  SetBase*match_set();
  SetBase*match_setparameter();
  static vector<directionT> directionsFromRayKeyword(KeywordToken*);
  SequenceBase* match_sequencenode();
  SquareVariable* match_squarevariable();
  PieceIdVariable* match_pieceidvariable();
  SetBase* match_parenthesizedsetbase();
  void show_error(string message);
  void show_error(string message,string message2);
  VectorNode* match_vectornode();
  vector<DirectionParameter> match_directionparameters();
  DirectionParameter* match_directionparameter();
  vector<Direction>match_direction();
  vector<Direction> match_raydirections(bool * isattack);
  OrbitNode* match_orbitnode();
  OrbitNode* match_shifttransform();
  OrbitNode* match_fliptransform();
  OrbitNode* match_swapcolortransform();
  NumericVariable* match_numericvariable();
  StringVariable* match_stringvariable();
  MatchCountNode* match_matchcountnode();
  FindNode* match_findnode();
  SetBase* match_inexpr();
  AnyNode* match_anynode();
  BetweenNode* match_betweennode();
  LoopNode* match_loopnode();
  ExtensionNode* match_extensionnode();
  OnNode* match_onnode(Node* prefix);
  Node* match_powernode();
  CurrentNode* match_currentnode();
  Node* match_squareloopnode();
  Node* match_pieceloopnode();
  OrNode* match_ornode(Node*prefix);
  Node* match_hascommentnode();
  string match_opassignmentname();
  string match_nonemptyquotedstring(); //an empty quoted string fails to match
  bool match_quotedstringvalue(string * valp); 
  bool match_keywords(string v1, string v2);
  Node* match_stringconverter();
  Node* match_parenthesizednumeric();
  Node* match_player();
  EloNode* match_elonode();
  PlyNode* match_plynode();
  colorT match_color();
  bool match_colonequal();
  YearNode* match_yearnode();
  NumericVariable* match_optionalnumericvariable(bool ismax);
  SeqConstituent* match_seqconstituent(SeqDir);
  vector<SeqConstituent*>match_seqconstituents(SeqDir);
  Range* match_repeat_range();
  HolderConstituent*match_holderconstituent(SeqDir);
  VectorConstituent*match_vectorconstituent(SeqDir);
  SeqConstituent*match_seqsuffix(SeqConstituent*c);
  bool match_lparen();
  bool match_rparen();
  bool match_lbrace();
  bool match_rbrace();
  bool match_plus();
  bool match_star();
  bool match_special(string v);
  Variable* match_variabledefinition(string classname);
  Variable* match_variable_use();
  string match_id();
  Node* match_assignnode();
  string match_relationoperator();
  string match_arithmeticoperator();
  string match_special();
  Node* match_numeric();
  NumberNode* match_numbernode();
  string match_addoperator();
  string match_plusoperator();
  string match_multoperator();
  Node* make_relational_op_node(const string& op, Node* left, Node* right);
  bool match_intvalue(int*);
  Node* match_ifnode();
  Node* match_lambda_definition();
  vector<Token*> match_lambda_body();
  LambdaCallNode* match_lambda_use();
  static int nextid();
  Node* match_squarecoordinate();
  Node*match_makesquare();
  Node*match_parens();
  SetBase* match_connectedpawns();
  SetBase* match_doubledpawns();
  SetBase* match_isolatedpawns();
  SetBase* match_passedpawns();
  Node* node_from_fen(const string&fen, string&message);
  Node* match_fen();
  vector<Transform*> transforms_from_keyword(const string& name);
  Node* orbitnode_from_keyword(const string& name, Node*node);
  Node* match_preamble(const vector<string>&preamble);
  Node* apply_preamble_transforms(const vector<string>& preamblenames,Node*node);
  VirtualMainlineNode* match_virtualmainlinenode();
  Node*match_true();
  Node*match_false();
  EchoNode*match_echonode();
  PositionVariable* match_positionvariable();
  MatchNode* match_matchnode();
  Node* match_distancenode();
  LcaNode* match_lcanode();
  ExtremalNode* match_extremalnode();
  ToMoveValueNode* match_tomovevaluenode();
  ColorValueNode* match_colorvaluenode();
  Node* match_consecutivemovesnode();
  TransformVariable* match_transformvariable();
  vector<Transform*> match_qtransforms();
  TransformVariable*match_existingtransformvariable();
  bool match_bar();
  bool match_ampersand();
  bool match_colon();
  UnionNode* match_unionnode();
  Node*match_node();
  Node* match_or_x();
  Node* match_and_x();
  Node*match_relop_x();
  Node*match_addop_x();
  Node*match_mulop_x();
  Node*match_union_x();
  Node*match_intersect_x();
  Node*match_with_x();
  Node*match_primitive();
  ComplementNode*match_complementnode();
  NumericVariable* match_existingnumericvariable();
  StringVariable* match_existingstringvariable();
  bool match_rangeconstituent(int*, NumericVariable**);
  Range* match_constant_range();
  PositionIndexNode* match_positionindexnode();
  ColorTypeNode* match_colortypenode();
  DepthNode* match_depthnode();
  SetBase* match_colorsquare(); //light or dark
  SortNode*match_sortnode();
  PieceLoc*match_promoteexp();
  bool match_move_promote(PieceLoc**promotep);
  bool match_move_enpassant(SetBase**epsquarep);
  bool match_move_capture(SetBase**capturep);
  bool match_move_castle(SetBase**fromp, SetBase**top);
  bool match_move_from(SetBase**fromp);
  bool match_move_to(SetBase**top);
  SetBase* set_from_string(const string & description);
  Node* match_in_x();
  AbsNode* match_absnode();
  Node* match_type();
  Node* match_unaryminus();
  bool match_leftarrow();
  bool match_rightarrow();
  DashToken* getDash();
  Node* match_attack_x();
  Node* match_opassignment();
  ChildNode* match_childnode();
  ParentNode* match_parentnode();
  PieceAssignNode* match_pieceassignnode();
  bool match_matchstringfeature();
  PieceIdNode*match_pieceidnode();
  bool match_commentlevelfeature();
  DescendantNode* match_descendantnode();
  SqrtNode* match_sqrtnode();
  GotoNode* match_gotonode();
  bool at_wildcard_terminator();
  string match_wildcardcharacter();
  NoTransformNode* match_notransformnode();
  Node* match_error();
  Node* match_hhdb();
  Node* match_hhdb_award();
  string match_hhdb_keyword();
  bool match_hhdb_keyword(string);
  Node* hhdbaward_sort(string typekey, bool hasspecial);
  Node* match_regexnode();
  Node* match_assertvariationsnode();
  StringLiteralNode* match_stringliteralnode();
  string match_stipulation_parameter();
  Node* match_string(); //by analogy with match_numeric
  Node* match_sortable();
  Node* match_currentfen();
  Node* match_stringtointnode();
  bool isOpAssignmentName(const string&);
  Node* make_op_node(char op, Node*left, Node*right);
  Node* match_assignment();
  Node* match_tagbuiltinnode();
  Node* match_tagnode();
  Node* match_tagsetnode();
  Node* match_groupnumbernode();
  Node* match_groupindexnode();
  bool match_tildetilde();
  Node* match_assertnode();
  Node* match_keyword_optional_regex(string keyword, const string&prefix);
  Node* match_isboundnode();
  Node* match_substringnode();
  bool match_groupnumbertoken(int*valp,string*locationp);
  bool match_groupindextoken(int*valp,string*locationp);
  bool match_lbracket();
  bool match_rbracket();
  bool match_comma();
  bool match_equalsign();
  Node* match_substring_x();
  BracketRange*match_bracketrange();
  Node*match_dictionaryaccessnode();
  ReadFileNode*match_readfilenode();
  WriteFileNode*match_writefilenode();
  Node*match_stringindex();
  HhdbHasCookNode* match_hhdbhascooknode();
  Node* match_trailing_quoted_string(Node*);
  Node*match_dictionaryiterator();
  Node*match_dictionaryiterator61();
  Node* match_removecommentnode();
  Range* match_repeat_range_nocomma();
  Range* match_repeat_range_comma();
  CurrentTransformNode* match_currenttransformnode();
  Node*match_string_simple();
  StringAsciiNode*match_stringasciinode();
  Node*match_whilenode(); //this includes match_whileregex();
  Node*match_emptyset();
  Node*match_strconstituent();
  Node* match_unbind();
  AbortNode*match_abortnode();
  CaseConvertNode*match_caseconvertnode();
  Node*match_dash_tie_x(); //in toplevel, 
  Node*match_dashnode_from_prefix(SetBase*left,DashToken*); //MoveLegalNode or DashNode
  Node*match_pastmovenode();
  /* pathcons*/
  bool qmatch_wildcardstar();
  bool qmatch_wildcardplus();
  GenericEqualNode* match_genericequalnode();
  string match_legal_option();
  vector<string>match_legal_options();
  vector<string>match_atomicnames();
  vector<Variable*>atomicvariables_from_names(const vector<string>&);
  Range*match_path_repeat_range(); //this is the version used by the new path, i.e. dash
  PiecePathNode*match_piecepathnode();
  ToNode*match_tonode();
  FromNode*match_fromnode();
  Token*read_wildcard();
  DashCon*match_dashcon();
  SetBase* match_dashargument();
  DashCon*match_ignoreleft_dashcon();
  PathCon*add_wildcard(PathCon*);
  PathCon*create_wildcard_node(PathCon*pathcon,Token*token);
  PathNode*match_pathnode();
  vector<PathCon*>match_pathcons();
  PathCon* match_pathcon();
  ChainCon* match_chaincon();
  HolderCon*match_holdercon();
  bool left_tie_follows();
  Node*match_dashcon_target();
  Node*match_dash_legal_suffix(SetBase*left,SetBase*right,bool iscount,bool islegal,bool ispseudolegal);
  bool match_wildcardplus();
  bool match_wildcardstar();
  PieceNameNode* match_piecenamenode();
  TypeNameNode* match_typenamenode();
  Node* match_dash_promotion();
  SetBase* match_dash_right();
  bool peek_equals_sign();
  Node* match_dash_target();
  MoveLegalNode*match_legal_dash();
  bool peek_lparen();
  Node* match_countmoves();
  PreviousDashNode*match_previousdashnode();
  Node*match_dictionaryretrieveorassign();
  Node*match_dictionary_unbind();
  Dictionary*match_dictionary_variable();
  Dictionary*match_dictionary();
  bool match_linecomment();
  bool match_endlinecomment();
  Node* match_try();
  bool match_attackarrow(AttackArrowDirection);
  AttackArrowDirection match_attackarrow();
  Node*match_attackarrow_x();
  Node*match_matefunction();
  void load_matefunction();
  bool match_Aa();
  bool match_element();
  bool match_forall();
  PieceLoopNode* match_symbolicpieceloop();
  SquareLoopNode* match_symbolicsquareloop();
  bool match_symbolicpiecedeclaration();
  LastGameNumberNode*match_lastgamenumbernode();
  Node*match_anticipatenode();
  string get_unique_name(const string &prefix);
};  
